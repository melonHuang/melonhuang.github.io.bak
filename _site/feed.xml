<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>MelonSpace</title>
    <description>Enjoy everyday
</description>
    <link>http://melonhuang.github.io//</link>
    <atom:link href="http://melonhuang.github.io//feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 08 Apr 2015 20:09:12 +0800</pubDate>
    <lastBuildDate>Wed, 08 Apr 2015 20:09:12 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>翻译-DOMContentLoaded和样式表</title>
        <description>&lt;p&gt;DOMContentLoaded是现代Javascript用途中重要的一部分。在HTML代码被从服务器完全获取，完整的DOM树被创建，并且脚本可以通过DOM API操作DOM树时，DOMContentLoaded事件会被触发。通常，这个时间点被成为&amp;quot;DOM Ready&amp;quot;。与load事件相比，图片，iframe，插件等资源不会阻塞DOMContentLoaded事件。因此，DOMContentLoaded事件对希望尽早给页面绑定Javascript行为的开发者是一个理想的选择。&lt;/p&gt;

&lt;p&gt;几乎所有Javascript框架都允许使用者在&amp;quot;on DOM ready&amp;quot;的时候执行他们的脚本。将代码定义在一个私有的function scope中并在&amp;quot;on DOM ready&amp;quot;的时候执行是一个常用的Javascript编程模式。在这样的启动方法中，可借助于选择器引擎查询DOM。例如，获得了DOM的信息，给元素绑定监听事件，修改DOM。正如我所说，这个模式对于DOM脚本编程非常重要。&lt;/p&gt;

&lt;p&gt;我们在著名的框架中是如何使用DOMContentLoaded事件的呢：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;c1&quot;&gt;//jQuery:&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;jQuery&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ready&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{});&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;jQuery&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{});&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//Prototype:&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;observe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;dom:loaded&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{});&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//Mootools:&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;addEvent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;domready&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;IE8和IE8以下的IE浏览器不支持DOMContentLoaded事件，所以这些框架通过使用&lt;a href=&quot;http://javascript.nwbox.com/IEContentLoaded/&quot;&gt;doScroll()的实现方式&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;DOMContentLoaded和外部样式表&lt;/h2&gt;

&lt;p&gt;为了在我的Javascript教程中准确地描述DOMContentLoaded事件的行为，我进行了很多测试。最主要的问题是：外部样式表的加载是否会阻塞DOMContentLoaded事件？这个问题不是最新的，它已经被研究了很多年。&lt;/p&gt;

&lt;p&gt;对于大部分脚本，在样式表加载完成后再执行它们是有道理的，因为这些脚本依赖于应用到DOM上的CSS规则。例如，对于某些脚本的初始化，它们依赖于元素的位置，大小。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en/docs/Gecko-Specific_DOM_Events#DOMContentLoaded&quot;&gt;Mozilla&lt;/a&gt;中定义到，DOMContentLoaded会在文档被解析，并且里面的脚本被执行后触发。但实际上，DOMContentLoaded有时候会根据脚本的位置和类型，被样式表的加载影响。&lt;/p&gt;

&lt;h2&gt;使用外部脚本在Gecko和Webkit中阻塞DOMContentLoaded&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;测试用例#1：样式表后无脚本
如果样式表之后没有脚本，那么DOMContentLoaded不会被阻塞。这对所有支持DOMContentLoaded的浏览器都是成立的。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;测试用例#2：样式表后有外部脚本
There are several exceptions in which Gecko and Webkit do wait for the stylesheet to load before DOMContentLoaded fires. 。最常见的案例是&lt;code&gt;&amp;lt;link rel=&amp;quot;stylesheet&amp;quot;&amp;gt;&lt;/code&gt;后面跟着一个外部脚本&lt;code&gt;&amp;lt;script src=&amp;quot;...&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;。这个脚本可以放在文档的任意部分，只要它在&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;元素后面。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;测试用例：
html:
&lt;code&gt;html
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;http://molily.de/weblog/stylesheet.css&amp;quot;&amp;gt;
&amp;lt;script src=&amp;quot;http://molily.de/weblog/script.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div id=&amp;quot;element&amp;quot;&amp;gt;The element&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;stylesheet.css:
```css&lt;/p&gt;

&lt;h1&gt;element { color: red; }&lt;/h1&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;script.js:
```javascript
document.addEventListener(&amp;#39;DOMContentLoaded&amp;#39;, function () {
    // should read #FF0000 or rgb(255, 0, 0)
    alert(getComputedStyle(document.getElementById(&amp;#39;element&amp;#39;), null).color);
}, false);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了论证浏览器之间的差异，我强制给HTTP服务器给样式表添加了3秒的延迟，这样文档就可以在样式表被完全接受到前解析完毕。&lt;/p&gt;

&lt;p&gt;上面的代码在Firefox，Safari和Chrome中的行为都如我所预期，但是在Opera中不同。&lt;/p&gt;

&lt;p&gt;在样式表后放置外部脚本是一个常见的做法。当你希望在脚本中读写样式已经生效的DOM时，&lt;a href=&quot;http://api.jquery.com/ready/&quot;&gt;jQuery文档&lt;/a&gt;推荐这种编写元素的顺序。即使这个样式表需要10秒来加载，并且文档在1秒内就被获取并解析完毕，DOMContentLoaded事件也会等到样式表加载并解析完毕后才触发。&lt;/p&gt;

&lt;p&gt;这里涵盖了DOM脚本编程的优缺点。你可以依赖于样式表，但你的脚本必须一直等待，直到样式表加载完毕，才能遍历DOM数并添加监听事件。&lt;/p&gt;

&lt;h2&gt;背景知识：HTML解析&lt;/h2&gt;

&lt;p&gt;这个观测基于更底层的浏览器怪癖-HTML解析和脚本执行算法。&lt;/p&gt;

&lt;h3&gt;Gekco, Webkit和IE中，样式表会阻塞外部脚本的执行&lt;/h3&gt;

&lt;p&gt;在这些浏览器中，&lt;strong&gt;样式表的加载会阻塞外部脚本的执行。&lt;/strong&gt; 测试用例#2的文档head中包含了以下标记：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;link&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;rel=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;stylesheet&amp;quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;http://molily.de/weblog/stylesheet.css&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;http://molily.de/weblog/script.js&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当前的Gecko和Webkit版本，和IE8会并行下载样式表和脚本。但是不会执行脚本，直到样式表被加载完毕。并且同时它们不会渲染页面。你可以通过使用Firebug的网络标签，Safari Webjianchaqi 的Resources标签，或者常用的Chrome开发者工具的Timeline标签来验证这一点。
&lt;img src=&quot;http://molily.de/assets/domcontentloaded/chrome-timeline-my.png&quot; alt=&quot;chrome-timeline&quot;&gt;
由于DOMContentLoaded会在所有脚本都执行完毕后才触发，因此DOMContentLoaded事件会在样式表被加载并解析后才触发。&lt;/p&gt;

&lt;p&gt;对于IE8也是如此，当然，除了DOMContentLoaded事件。&lt;/p&gt;

&lt;h2&gt;在Opera中，样式表不会阻塞外部脚本的执行&lt;/h2&gt;

&lt;p&gt;但是，这个延迟DOMContentLoaded的方法在Opera中不生效。Opera一加载完脚本后就会开始解析。这导致了增加的渲染，提高了感知的性能，但是会出现从无样式变换到有样式的闪烁。&lt;/p&gt;

&lt;p&gt;为了兼容Opera的差异，jQuery1.2.1到1.2.6在DOMContentLoaded时间后进行了额外的检查。在这些jQuery版本中，它保证DOM ready事件触发时，所有样式表都已经被加载并解析了。jQuery 1.3抛弃了&lt;a href=&quot;http://github.com/jquery/jquery/commit/4c1e12e889f2a70bfa3603fed9d1cabe67d294e0&quot;&gt;这个方案&lt;/a&gt;。（据我所知，Prototype和Mootools完全忽略了这个问题。）&lt;/p&gt;

&lt;h2&gt;在Gecko和IE中，样式表会阻塞内部脚本的执行&lt;/h2&gt;

&lt;p&gt;内部脚本也可以引起不同的浏览器行为：&lt;/p&gt;

&lt;p&gt;测试用例#3
&lt;code&gt;html
&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;http://molily.de/weblog/stylesheet.css&amp;quot;&amp;gt;
&amp;lt;script&amp;gt; Some inline JavaScript code &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在IE和Gecko中，样式表会阻塞随后内部脚本的执行。因此，DOMContentLoaded事件被延迟了。&lt;/p&gt;

&lt;p&gt;在Webkit和Opera中，内部脚本会马上执行。因此，DOMContentLoaded会在HTML被解析完后立即执行，而不会被样式表阻塞。&lt;/p&gt;

&lt;h2&gt;总结&lt;/h2&gt;

&lt;p&gt;DOMContentLoaded和样式表概述
| 浏览器引擎 vs. 行为| 当只有stylesheet link前面有脚本时，样式表是否会延迟DOMContentLoaded | 样式表是否会阻塞随后的外部脚本，因此延迟DOMContentLoaded（测试用例#2） | 样式表是否会阻塞随后内部脚本的执行，因此延迟DOMContentLoaded（测试用例#3）|
| ---- | ---- | ---- | |
| Presto(Opera)   | no    | no   | no |
| Webkit(Safari, Chrome) | no | yes | no |
| Gecko(Firefox)| no | yes| yes |
| Trident(IE)| no | yes| yes |&lt;/p&gt;

&lt;h2&gt;HTML5来拯救我们吧&lt;/h2&gt;

&lt;p&gt;从前，DOMContentLoaded以Mozilla发明的一个Firefox插件。它未经过Javascript社区来审核这是否是一个通用的实现。这就是为什么Opera和Apple使用了这个事件，实现的却不尽相同。因此DOMContentLoaded有着不同的含义。&lt;/p&gt;

&lt;p&gt;幸运的是，最重要的web标准:HTML5,将会标准化&lt;a href=&quot;http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#the-end&quot;&gt;DOMContentLoaded&lt;/a&gt;事件，和&lt;a href=&quot;http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html&quot;&gt;HTML解析过程&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;根据HTML5，DOMContentLoaded是一个纯粹的DOM ready事件，与样式表无关。但是，HTML5解析算法要求浏览器延迟脚本的执行，直到前面所有的样式表都加载并解析完毕。让我们复习一下测试用例#2：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;link&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;rel=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;stylesheet&amp;quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;http://molily.de/weblog/stylesheet.css&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;http://molily.de/weblog/script.js&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当HTML5解析器遇到&lt;code&gt;&amp;lt;script&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;标签时，整个解析进程都被暂停了。首先，当是外部脚本时，浏览器会请求script的资源。然后，浏览器等待前面的样式表加载完毕。第三，Javascript引擎解析并执行下载的Javascript代码。最后，解析器继续解析HTML文档。&lt;/p&gt;

&lt;p&gt;假设起码会有一些脚本在样式表后面，它保证了在“Dom ready”的时候所有样式表都加载完毕了。这是因为DOMContentLoaded会在整个文档都解析完毕后触发。&lt;/p&gt;

&lt;p&gt;原来Gecko和IE早在这一点上与HTML5达成一致。但是我们不知道Webkit和Opera是否会切换到HTML5解析规范，也不知道触发HTML5解析器是否需要&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;正如上面所说，解析规则是一个巨大的性能影响因素。如果我们把所有样式表和脚本都放在文档的head，那么解析器会等待这些资源全部加载完毕，再去解析body。为了提供更快的性能，基本的原则就是将样式表放在头部，将脚本放在底部。（见&lt;a href=&quot;http://stevesouders.com/hpws/rules.php&quot;&gt;High Performance Web Sites by Stev Souders&lt;/a&gt;）&lt;/p&gt;

&lt;h2&gt;原文：&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://molily.de/domcontentloaded/&quot;&gt;地址&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 08 Apr 2015 00:00:00 +0800</pubDate>
        <link>http://melonhuang.github.io//javascript/2015/04/08/domcontentloaded-and-stylesheet.html</link>
        <guid isPermaLink="true">http://melonhuang.github.io//javascript/2015/04/08/domcontentloaded-and-stylesheet.html</guid>
        
        
        <category>javascript</category>
        
      </item>
    
      <item>
        <title>网页显示大小的变化，从PC到Mobile-第一部分</title>
        <description>&lt;p&gt;手机、pad等移动设备已成为生活中必不可缺少一部分。与传统PC相比，这类设备的尺寸小很多, 分辨率也有略微差别。
那么网页中一个宽度为100px的按钮，在手机上显示，与在PC上显示，视觉上相差多少呢？&lt;/p&gt;

&lt;p&gt;网页大小的变化要从两个方面来分析：&lt;br&gt;
1. 屏幕参数dpi, dip&lt;br&gt;
2. 网页缩放&lt;/p&gt;

&lt;p&gt;这篇文章先在网页缩放比例为100%的基础上解释屏幕参数对网页显示大小的影响。&lt;/p&gt;

&lt;p&gt;该文章的第二部分（未出）将会解释网页缩放原理，敬请期待。咯咯咯~~&lt;/p&gt;

&lt;h2&gt;理解屏幕参数&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;屏幕尺寸&lt;br&gt;
意义：用户屏幕的整体大小。数值为屏幕对角线长度。&lt;br&gt;
eg: iphone5 4inch，是指iphone5对角线的长度为4inc&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;分辨率(Resolution)&lt;br&gt;
意义：用户屏幕有多少个物理像素（可以发光的点）。&lt;br&gt;
eg. 1980*1080分辨率，代表水平方向有1980个像素长度，垂直方向有1080个像素长度。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;dpi(dots per inch)/ppi(pixel per inch)&lt;br&gt;
意义：每英寸有多少个像素点。即屏幕像素密度。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;移动设备屏幕参数带来得问题&lt;/h2&gt;

&lt;p&gt;以iphone5和iMac为例：
| 手机\参数|尺寸（英寸）|分辨率|  屏幕密度dpi|
| ---- | ---- | ---- | ---- | 
|iphone5  |4     | 1136 * 640|326|
|iMac       |21.5| 1980 * 1080| 102|&lt;/p&gt;

&lt;p&gt;iphone5的屏幕密度dpi比iMac的要高三倍左右，换过来说，1px在iphone5上显示的宽度要是iMac上的1/3左右。 &lt;/p&gt;

&lt;p&gt;于是带来了一个问题，&lt;strong&gt;同样像素宽度的元素，在手机上看起来比PC上小很多&lt;/strong&gt;。16px的字体，在手机上看好像pc上的5px，难以阅读！&lt;/p&gt;

&lt;h2&gt;dip—不依赖设备的长度单位&lt;/h2&gt;

&lt;p&gt;为了解决上面的问题，Android提出了dip（device independent pixel)的概念，IOS上也有类似的概念。&lt;/p&gt;

&lt;p&gt;dip(device independent pixel), 也叫dp&lt;br&gt;
    意义：一个长度单位。1dp约等于1/160英寸。1dp代表的长度由屏幕厂商根据具体情况设定。&lt;/p&gt;

&lt;p&gt;通常Android开发者设置元素大小时不使用px作为单位。而是使用dp(即dip)作为单位。那么在不同设备上，显示的大小都会差不多。&lt;/p&gt;

&lt;h3&gt;devicePixelRatio&lt;/h3&gt;

&lt;p&gt;devicePixelRatio = 1dp的宽度 / 1px的宽度。&lt;br&gt;
意义：它的值带表1dp长度单位内有多少个物理像素。&lt;/p&gt;

&lt;p&gt;对于iPhone来说，非视网膜设备的devicePixelRatio为1，视网膜设备为2。
对Android来说，它们的devicePixelRatio从0.75 - 2不等。见下表。&lt;/p&gt;

&lt;h3&gt;dip长度的设定（我自己的理解）&lt;/h3&gt;

&lt;p&gt;1dp代表的长度，是由屏幕厂商根据屏幕参数决定的。iphone5的一个物理像素的宽度约为pc上的1/3，因此一个大小为12px的字体在iphone5上看比PC上只有三分之一的大小，这样必须看不见！因此Android开发者都会使用dp作为单位，我们希望12dp的字体在手机上能看的清，如果12dp的长度有24个物理像素，那字体应该看起来约为pc上的2/3。恩，这样可以接受，很好，那就1dp长度内有2个px吧，于是devicePixelRatio等于2。&lt;/p&gt;

&lt;p&gt;1dp的长度在各个设备下略有不同，但都约为1/160英寸，因此16dp的长度在各个屏幕下看大小略微不同，但也差不多。&lt;/p&gt;

&lt;h2&gt;移动端浏览器的秘密优化-单位转换&lt;/h2&gt;

&lt;p&gt;在进行Web开发时，我们通常还是使用百分比，或者px作为单位。但是移动端浏览器在渲染时，会根据devicePixelRatio转换长度。如iphone5的devicePixelRatio为2，网页中得一个字体为12px，那么在手机上渲染时，浏览器会重新计算这个字体的大小为2*12=24px。因此在字体看起来差不多大。&lt;/p&gt;

&lt;h2&gt;iphone5 vs iMac，实例分析&lt;/h2&gt;

&lt;p&gt;iphone5的dpi为326, iMac的dpi为102, 因此iphone5上16px的大小为iMac上的102/326 * 16 ~= 4.8，16px的字体如果不进行单位转换，在iphone5上看，好像iMac上的4.8px大。iphone5的devicePixelRatio为2，移动端浏览器渲染时，将16px的单位转为16dp，因此在iphone上看起来，好像是iMac上的4.8 * 2 ~= 10px。&lt;/p&gt;
</description>
        <pubDate>Thu, 27 Mar 2014 00:00:00 +0800</pubDate>
        <link>http://melonhuang.github.io//css/2014/03/27/the-size-of-page-from-pc-to-mobile.html</link>
        <guid isPermaLink="true">http://melonhuang.github.io//css/2014/03/27/the-size-of-page-from-pc-to-mobile.html</guid>
        
        
        <category>css</category>
        
      </item>
    
      <item>
        <title>BFC神奇背后的原理</title>
        <description>&lt;p&gt;&lt;code&gt;BFC&lt;/code&gt;已经是一个耳听熟闻的词语了，网上有许多关于&lt;code&gt;BFC&lt;/code&gt;的文章，介绍了如何触发&lt;code&gt;BFC&lt;/code&gt;， 以及&lt;code&gt;BFC&lt;/code&gt;的一些用处（如清浮动，防止margin重叠等）。虽然我知道如何利用&lt;code&gt;BFC&lt;/code&gt;解决这些问题，但当别人问我&lt;code&gt;BFC&lt;/code&gt;是什么，我还是不能很有底气地解释清楚。于是这两天仔细阅读了CSS2.1 spec, 和许多文章，来全面地理解BFC：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;BFC&lt;/code&gt;是个什么？&lt;br&gt;&lt;/li&gt;
&lt;li&gt;哪些元素会生成&lt;code&gt;BFC&lt;/code&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BFC&lt;/code&gt;的神奇的作用，及背后的原理&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;一、BFC是什么？&lt;/h2&gt;

&lt;p&gt;在解释&lt;code&gt;BFC&lt;/code&gt;是什么之前，需要先介绍&lt;code&gt;Box&lt;/code&gt;, &lt;code&gt;Formatting context&lt;/code&gt;的概念。&lt;/p&gt;

&lt;h3&gt;Box: CSS布局的基本单位&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Box&lt;/code&gt;是CSS布局的对象和基本单位， 直观点来说，就是一个页面是由很多个&lt;code&gt;Box&lt;/code&gt;组成的。元素的类型和display属性，决定了这个&lt;code&gt;Box&lt;/code&gt;的类型。 不同类型的&lt;code&gt;Box&lt;/code&gt;， 会参与不同的&lt;code&gt;Formatting context&lt;/code&gt;(一个决定如何渲染文档的容器)，因此&lt;code&gt;Box&lt;/code&gt;内的元素会以不同的方式渲染。让我们看看有哪些盒子：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;block-level box&lt;/code&gt;: display属性为block, list-item, table的元素，会生成&lt;code&gt;block-level box&lt;/code&gt;。并且参与&lt;code&gt;block fomatting context&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;inline-level box&lt;/code&gt;: display属性为inline, inline-block, inline-table的元素，会生成&lt;code&gt;inline-level box&lt;/code&gt;。并且参与&lt;code&gt;inline formatting context&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;run-in box&lt;/code&gt;: css3中才有， 这儿先不讲了&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Formatting context&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Formatting context&lt;/code&gt;是W3C CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。  &lt;/p&gt;

&lt;p&gt;最常见的&lt;code&gt;Formatting context&lt;/code&gt;有&lt;code&gt;Block fomatting context&lt;/code&gt;(简称&lt;code&gt;BFC&lt;/code&gt;)和&lt;code&gt;Inline formatting context&lt;/code&gt;(简称&lt;code&gt;IFC&lt;/code&gt;)。&lt;/p&gt;

&lt;p&gt;CSS2.1 中只有&lt;code&gt;BFC&lt;/code&gt;和&lt;code&gt;IFC&lt;/code&gt;, CSS3中还增加了&lt;code&gt;GFC&lt;/code&gt;和&lt;code&gt;FFC&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;BFC 定义&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;BFC&lt;/code&gt;(&lt;code&gt;Block formatting context&lt;/code&gt;)直译为&amp;quot;块级格式化上下文&amp;quot;。它是一个独立的渲染区域，只有&lt;code&gt;Block-level box&lt;/code&gt;参与， 它规定了内部的&lt;code&gt;Block-level Box&lt;/code&gt;如何布局，并且与这个区域外部毫不相干。&lt;/p&gt;

&lt;h4&gt;BFC布局规则：&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;内部的&lt;code&gt;Box&lt;/code&gt;会在垂直方向，一个接一个地放置。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Box&lt;/code&gt;垂直方向的距离由margin决定。属于同一个&lt;code&gt;BFC&lt;/code&gt;的两个相邻&lt;code&gt;Box&lt;/code&gt;的margin会发生重叠&lt;br&gt;&lt;/li&gt;
&lt;li&gt;每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BFC&lt;/code&gt;的区域不会与&lt;code&gt;float box&lt;/code&gt;重叠。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BFC&lt;/code&gt;就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。&lt;/li&gt;
&lt;li&gt;计算&lt;code&gt;BFC&lt;/code&gt;的高度时，浮动元素也参与计算&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;二、哪些元素会生成BFC?&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;根元素&lt;/li&gt;
&lt;li&gt;float属性不为none&lt;/li&gt;
&lt;li&gt;position为absolute或fixed&lt;/li&gt;
&lt;li&gt;display为inline-block, table-cell, table-caption, flex, inline-flex&lt;/li&gt;
&lt;li&gt;overflow不为visible&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;三、BFC的作用及原理&lt;/h2&gt;

&lt;h3&gt;1. 自适应两栏布局&lt;/h3&gt;

&lt;p&gt;代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;style&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;body&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;300px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;relative&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nc&quot;&gt;.aside&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;100px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;150px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;background&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;#f66&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nc&quot;&gt;.main&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;200px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;background&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;#fcc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;aside&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;main&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;页面：&lt;br&gt;
&lt;img src=&quot;http://p1.qhimg.com/d/inn/4055c62a/4dca44a927d4c1ffc30e3ae5f53a0b79.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;/p&gt;

&lt;p&gt;根据&lt;code&gt;BFC&lt;/code&gt;布局规则第3条：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因此，虽然存在浮动的元素aslide，但main的左边依然会与包含块的左边相接触。&lt;/p&gt;

&lt;p&gt;根据&lt;code&gt;BFC&lt;/code&gt;布局规则第四条：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;BFC&lt;/code&gt;的区域不会与&lt;code&gt;float box&lt;/code&gt;重叠。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们可以通过通过触发main生成&lt;code&gt;BFC&lt;/code&gt;， 来实现自适应两栏布局。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-css&quot; data-lang=&quot;css&quot;&gt;&lt;span class=&quot;nc&quot;&gt;.main&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;overflow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;hidden&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当触发main生成&lt;code&gt;BFC&lt;/code&gt;后，这个新的&lt;code&gt;BFC&lt;/code&gt;不会与浮动的aside重叠。因此会根据包含块的宽度，和aside的宽度，自动变窄。效果如下：&lt;br&gt;
&lt;img src=&quot;http://p6.qhimg.com/t01077886a9706cb26b.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;/p&gt;

&lt;h3&gt;2. 清除内部浮动&lt;/h3&gt;

&lt;p&gt;代码: &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;style&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;.par&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;border&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5px&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;solid&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;#fcc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;300px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nc&quot;&gt;.child&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;border&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5px&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;solid&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;#f66&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;100px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;100px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;par&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;child&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;child&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;页面：&lt;br&gt;
&lt;img src=&quot;http://p1.qhimg.com/t016035b58195e7909a.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;/p&gt;

&lt;p&gt;根据&lt;code&gt;BFC&lt;/code&gt;布局规则第六条：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;计算&lt;code&gt;BFC&lt;/code&gt;的高度时，浮动元素也参与计算&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;为达到清除内部浮动，我们可以触发par生成&lt;code&gt;BFC&lt;/code&gt;，那么par在计算高度时，par内部的浮动元素child也会参与计算。&lt;/p&gt;

&lt;p&gt;代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-css&quot; data-lang=&quot;css&quot;&gt;&lt;span class=&quot;nc&quot;&gt;.par&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;overflow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;hidden&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果如下：&lt;br&gt;
&lt;img src=&quot;http://p2.qhimg.com/t016bbbe5236ef1ffd5.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;
￼&lt;/p&gt;

&lt;h3&gt;3. 防止垂直margin重叠&lt;/h3&gt;

&lt;p&gt;代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;style&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;#f55&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;background&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;#fcc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;200px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;line-height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;100px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;text-align&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;center&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;margin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;100px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;Haha&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;Hehe&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;页面：&lt;br&gt;
&lt;img src=&quot;http://p5.qhimg.com/t01b47b8b7d153c07cc.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;/p&gt;

&lt;p&gt;两个p之间的距离为100px，发送了margin重叠。&lt;br&gt;
根据BFC布局规则第二条：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Box&lt;/code&gt;垂直方向的距离由margin决定。属于同一个&lt;code&gt;BFC&lt;/code&gt;的两个相邻&lt;code&gt;Box&lt;/code&gt;的margin会发生重叠  &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们可以在p外面包裹一层容器，并触发该容器生成一个&lt;code&gt;BFC&lt;/code&gt;。那么两个P便不属于同一个&lt;code&gt;BFC&lt;/code&gt;，就不会发生margin重叠了。&lt;br&gt;
代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;style&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;.wrap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;overflow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;hidden&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;#f55&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;background&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;#fcc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;200px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;line-height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;100px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;text-align&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;center&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;margin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;100px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;Haha&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;wrap&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;Hehe&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果如下:&lt;br&gt;
&lt;img src=&quot;http://p3.qhimg.com/t0118d1d2badbb00521.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;/p&gt;

&lt;h2&gt;总结&lt;/h2&gt;

&lt;p&gt;其实以上的几个例子都体现了&lt;code&gt;BFC&lt;/code&gt;布局规则第五条：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;BFC&lt;/code&gt;就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因为&lt;code&gt;BFC&lt;/code&gt;内部的元素和外部的元素绝对不会互相影响，因此， 当&lt;code&gt;BFC&lt;/code&gt;外部存在浮动时，它不应该影响&lt;code&gt;BFC&lt;/code&gt;内部Box的布局，&lt;code&gt;BFC&lt;/code&gt;会通过变窄，而不与浮动有重叠。同样的，当&lt;code&gt;BFC&lt;/code&gt;内部有浮动时，为了不影响外部元素的布局，&lt;code&gt;BFC&lt;/code&gt;计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理。  &lt;/p&gt;
</description>
        <pubDate>Fri, 10 Jan 2014 00:00:00 +0800</pubDate>
        <link>http://melonhuang.github.io//css/2014/01/10/the-magic-bfc.html</link>
        <guid isPermaLink="true">http://melonhuang.github.io//css/2014/01/10/the-magic-bfc.html</guid>
        
        
        <category>css</category>
        
      </item>
    
  </channel>
</rss>
